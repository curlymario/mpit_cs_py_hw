# ==== Лекция 11 ====

# Матрица способов достижения клетки королём без диагонали (одношаговой ладьёй?)
# представляет из себя треугольник паскаля, повёрнутый на 45 градусов
# K[i][j] = K[i-1][j] + K[i][j-1] = K сочетаний для i по j (если i > j)
# 0  0  0  0  0  0  0  
# 0  1  1  1  1  1  1 
# 0  1  2  3  4  5  6 
# 0  1  3  6  10 15 21 
# 0  1  4  10 20 35 56 
# 0  1  5  15 35 70 126
# 0  1  6  21 56 126 252


# === Наибольшая общая подпоследовательность ===
# A, B — одномерные массивы чисел
# len(A) = N, len(B) = M
# Подпоследовательность A — список C, содержащий элементы A в исходном порядке, но, возможно, не все
# [] — подпоследовательность любой последовательности и наименьшая общая подпоследовательность
# Fij — длина наибольшей возможной подпоследовательности частей A и B:
# A[0:i] — часть A,содержащая первые i элементов
# B[0:j] — часть B, содержащая первые j элементов
# Fij = 1 + F(i-1)(j-1) если ai = bj
# Fij = max(F(i-1)j, Fi(j-1)), если ai != bj
# F0j = 0, Fi0 = 0

def lcs(A, B): # largest common subsequence
    F = [[0]*(len(B)+1) for i in range(len(A)+1)]
    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = 1 + F[i-1][j-1]
            else:
                F[i][j] = max(F[i-1][j], F[i][j-1])
    return F[-1][-1]    # последний элемент содержит длину 


# === Наибольшая возрастающая подпоследовательность ===
# Возрастающая, значит, отсортированная
# A — одномерный массив
# Fi — подпоследовательность (срез) A[0:i], которая заканчивается и содержит ai = A[i-1]
# Fi = max(Fj) + 1, j < i, ai > aj
# F0 = 0
def gis(A):     # greatest increasing subsequence
    F = [0]*(len(A)+1)
    for i in range(1, len(A)+1):
        m = 0   # текущий макисмум
        for j in range(0, i):   # j < i
            if A[i-1] > A[j-1] and F[j] > m: 
                m = F[j]
        F[i] = m + 1
    return F[len(A)]


# === Дискретный алгоритм укладки рюкзака ===
# Есть мешок и набор предметов
# M — максимальный вес вещей
# Каждый предмет имеет свою стоимость Si и массу Mj
# Найти максимальную стоимость предметов, которую можно унести



# ==== Лабораторная ====

# === Игра с Ферзём ===

def find_winning_steps_queen(M, N):
    """ Функция находит все проигрышные и выигрышные клетки в игре «Ферзя в угол».
        Для каждой клетки доски M × N вычисляется, сколько нужно ходов ферзю из этой клетки, чтобы добраться до точки (M, N)
        Все чётные значения являются проигрышными, все нечётные выигрышными.
        Функция возвращает двумерный массив со значениями "+" для выигрышных клеток и "−" для проигрышных
    """
    A = [[None]*M for m in range(N)]
    A[N-1][M-1] = 0
    for i in range(N-1):
        A[i][M-1] = 1
    for j in range(M-1):
        A[N-1][j] = 1
    # for i in reversed(range(N-1)):
    #     for j in reversed(range(M-1)):
    #         if (N-i) == (M-j):                            говно полное, нихуя это так не работает
    #             A[i][j] = 1
    #         elif A[i+1][j+1] == A[i+1][j] == A[i][j+1]:
    #             A[i][j] = 1 + A[i+1][j+1]
    #         else:
    #             m = max(A[i+1][j], A[i][j+1], A[i+1][j+1])
    #             if m % 2 == 0:
    #                 A[i][j] = 1 + m
    #             else:
    #                 A[i][j] = m
    for i in range(N):
        for j in range(M):
            if A[i][j] % 2 == 0:
                A[i][j] = "—"
            else:
                A[i][j] = "+"
    print(*A, sep="\n")
    print("===========================")
    return A

find_winning_steps_queen(6, 6)


# ==== Лекция 12 ====

# === Расстояние Левенштейна — Редакционное расстояние между строками — алгоритм редакционных имзенений ===
# A = 'колокол'
# B = 'молоко'
# Сколько требуется ошибок, чтобы кратчайшим путём перейти из A в B
# Ошибки:
# 1) перепутали символ
# 2) вставили лишний символ
# 3) потеряли нужный символ
# Fij — минимальное редакционное расстояние между срезами A[:i] и B[:j]
# Ответ F(NM) 
# Если A(i) == B(j), Fij = F(i-1,j-1)
# Если A(i) != B(j), Fij = 1 + min( F(i-1,j), F(i,j-1), F(i-1,j-1) )
# Крайние случаи: F0j = j, Fi0 = i, F00 = 0

def levenstain(A, B):
    F = [[i+j if i*j == 0 else 0 for j in range(len(B)+1)] for i in range(len(A)+1)]
    for i in range(1, len(A)+1):
        for j in range(1, len(B)+1):
            if A[i-1] == B[j-1]:
                F[i][j] = F[i-1][j-1]
            else:
                F[i][j] = 1 + min(F[i-1][j], F[i][j-1], F[i-1][j-1])
    return F[len(A)][len(B)]


# === Проверка равенства строк === O(N*M)
def equal(A, B):    # —> A == B
    if len(A) != len(B):
        return False
    for i in range(len(A)):
        if A[i] != B[i]:
            return False
    return True



# === Поиск подстроки в строке — Алгоритм Кнута-Морриса-Пратта ===
# S = "abacabadabacabafabacabadabacabafabacabadabacaba"
# sub = "dabac"

# Наивный вариант: [ O(N*M) ]

def search_substring_naive(S, sub):
    for i in range(0, len(S)-len(sub)):
        if equal(S[:i+len(sub)], sub):
            print(i)

# Префикс функция П строки
# Собственный суффикс — суффикс не равный строке (см. 'собственное подмножество')
# Пs — длина максимального собственного суффикса, который является префиксом
# П(s(i)) — Префикс строки s[:i]
# Если S(p+1) = S(i+1), то П(s(i)) = P + 1, где P = П(s(i-1)) —> П(s(i)) = П(s(i-1))+1 
# Рекурентно (или в цикле) ищем символ в S(i+1) в пи-функциях (префиксах), 
# пока не найдём такие минимальные префиксы и суффиксы, у которых есть в конце этот новый символ

# Псевдокод поиска префикса строки: [ O(M+N) ]
# П = [0 для всех i]
# для всех i строки S:
#   P = П(S(i-1))
#   Пока P > 0 и S(i) != S(p+1):
#       P = П(S(p))
#   Если S(i) = S(p+1), то
#       P += 1
# П(i) = P

# Алгоритм КМП: [ O(M+N) ]
# s* = sub + '#' + s
# И ищу для получившейся строки длину префикса
# В те моменты, когда Пi == len(sub)) —> мы нашли вхождение подстроки в строке
# Индекс вхождения: i - len(sub)

# === Практикум ===

# === Z-функция ===

# Дана строка s длины n
# Z(n) — массив длины n
# Z[i] содержит размер наибольшего числа символов, совпадающей с началом s, начиная с s[i]
# или
# Z[i] — длина наибольшего общего префикса строки s и её i-го суффикса. (назовём это отрезком совпадения)

# Z[0] обычно неопределён, но мы будем считать что Z[0] = 0 (это всё равно ни на что не влияет)

# Тривиальный алгоритм [ O(n^2) ]
def z_func_trivial(s, n):
    z = [0] * n
    for i in range(1, n-1):
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] += 1
    return z

# Эффективный алгоритм
# Будем поддерживать координаты [l;r] (начало и конец) самого правого отрезка совпадения
# здесь индекс r — граница, до которой мы уже просканировали строку

# варианты развития событий:
# а) i > r — текущая позиция лежит за пределами просканированного
# тогда ищем тривиальным алгоритмом
# если в итоге z[i] > 0, нужно обновить [l;r], т.к. i + z[i] - 1 > r
# б) i <= r — текущая позиция внутри отрезка [l;r]
# можем использовать подсчитанные значения, чтобы начать не с нуля
# отрезки s[l…r] и s[0…r−l] совпадают
# поэтому для z[i] возьмём соответствующее значение из s[0…r−l]
# z[i] = z[i−l]
# но нельзя чтобы вылезло за r
# поэтому z[i] = min(r−i+1, z[i−l])
# дальше опять ищем тривиальным алгоритмом

# т.о. есть два случая, к-е отличаются только инициацией z[i], а дальше тривиальный алгоритм
# тем не менее, такой вариант выполняется за линейное время
