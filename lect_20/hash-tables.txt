односвязный и двусвязный список
Односвязные — ссылка на след. Элемент
Двусвязные — +на предыдущий

### RAM — Random Acess Memory:
— Состоит из ячеек
— У каждой ячейки свой адрес
— Быстрый доступ к ячейке по адресу
— Поддержка адресной арифметики (адреса можно вычитать, складывать, и т.д)

Массив — В питоне в чистом виде не встречается
— Состоит из последовательных ячеек памяти
— Ссылка к началу массива
— Знаем адрес в памяти. Можем найти через адресную арифметику (прибавляя известное смещение)
— Доступ по индексу O(1), поиск O(1)
— Нельзя расширить, за пределами массива могут храниться данные, нужно пересоздавать массив

Связный список
— Данные хранятся в памяти в произвольном порядке. Расширение производится добавлением ссылки на новую ячейку.
— Доступ к следующему значению определяется сдвигом от начала по ссылкам
— Добавление и удаление О(1)
— Поиск O(n), доступ по индексу О(n)

### Проблема:
Высоконагруженная система с частым обращением. Нужна структура данных.
Хотим, чтобы добавление и удаление — О(1), поиск наличия значения — О(1). Порядок (поиск по индексу) не важен.
Массив быстрее доступ, но для расширяемости должен занимать слишком много места

Хэш-таблица
— Некоторый массив фиксированной длины
— С помощью функции (хэш-функции) преобразуем данные в адрес (хэш)
— Записываем данные в ячейку памяти по полученному адресу, а адрес кладём в случайное место в массиве

+ Мгновенный доступ О(1)
+ Занимает мало места
- Не сохраняется порядок
- Хэш-функция тоже занимает время, для маленьких баз быстрее создать список и ходить по нему
- В одну ячейку может попасть несколько телефонов (проблема коллизий) — хэши совпадают,
потому что хэшей меньше, чем данных (принцип Дирихле)

### Решения проблемы коллизий

1. Закрытая адресация (метод цепочек)
— Храним не само значение, а список значений (массив списков)
— Списки небольшие
— Можно легко добавлять и удалять элементы
— Поиск О(1 + ф), где ф — коэффициент заполненности таблицы, отношение числа элементов к размеру таблицы
— При большом ф таблицу нужно перестраивать

2. Открытая адресация
— Задаём ограничение на число данных (ф <= 1)
— При коллизии — кладём данные в ближайшую свободную ячейку
— Как искать свободные ячейки? Последовательность проб:
    Пробирование
        Линейное пробирование
        — последовательным перебором ячеек добавляем элементы в следующие свободные ячейки
        — поиск: сверяем, есть ли данные в ячейке. если нет, значит данных в таблице нет
        если в ячейке есть другие данные, ищем дальше подряд, пока не нашли данные или не дошли до пустой ячейки
        — если таблица закончилась, начинай сначала. если ф = 1, поиск — тета(n)
        Линейное пробирование с коэффициентом
        — Используем не следующую ячейку, а с коэффициентом сдвига k, чтобы уменьшить число коллизий
        Квадратичное пробирование
        — Коэффициент сдвига — квадрат натурального числа (1, 4, 9, 16, …)
    Двойное хэширование
    — две хэш-функции H1 и H2
    — кладём данные в ячейку H1(x)
    — чтобы найти коэфициент сдвига при коллизии, кладём в ячейку H1(x) + H2(x)
    — Самый популярный метод, дающий очень низкое число коллизий

### Хэширование — преобразование массива вводимых данных произвольной длины
в битовую строку (массив) фиксированной длины (хэш),
выполняемое определённым алгоритмом (хэш-функция)

Свойства:
— Вычислительная мощность (как быстро)
— Разрядность (как много данных)
— Криптостойкость (возможность получить данные по хэшу, скорость подбора, взлома)

Хорошая х-функция:
— минимальное количество коллизий
— Равномерное распределение ответов
— Быстрое вычисление

Идеальная функция
— Без коллизий
— Мгновенное вычисление

Применение
— Хранение и поиск данных (БД)
— Компьютерная графика
— Контрольная сумма (проверка целостности)
— Инфобезопсность и криптография (пароли и эл. подписи)

### Хэш-функции

Остаток от деления на какое-то число
— не криптостойкое (знаем число — легко обернуть)
— отсутствует лавинный эффект (близкие значение = близкие результаты) (хорошо для компьютерной графики)

Полиноминальный хэш
x = 1576
k = 2
1*k^3 + 5*k^2 + 7k + 6 = 48
— не криптостойкий
— при некоторых N много коллизий

XOR-кэширование
a   b   a XOR b (a^b) — исключающее ИЛИ, сложение по модулю 2
0   0   0
0   1   1
1   0   1
1   1   0

11010101
^
10011011
--------
01001110 — XOR-сумма
— не криптостойкий
— отсутствует лавинный эффект
— хорошо работает с символьными строками

Добавочный код
— остаток от деления полинома на тестовый полином
— для контрольных сумм
— не криптостойкий

Семейство MD (Message Digest)
— MD4 (взломан)
— MD5 (взломан)
— MD6

Семейство SHA (Secure Hash Algorithm)
— SHA-1 (взломан)
— SHA-2 (взломан)
SHA-224, SHA-256, …
— SHA-3 (Keccak)

### Hash в Python

— Словари dict()
— Множества set()