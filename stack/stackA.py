# ==== Стэк или очередь LIFO ====
# Нормальная очередь: FIFO: First in, first out
# LIFO: Last in, first out
# две базовые операции: push (in) и pop (out)
# size — узнать глубину стека
# top — узнать, кто наверху
# is_empty — пуст ли стек?

# порядок разработки структуры данных — структурное программирование
# 1) базовый use case

# >>> push(1)
# >>> push(2)
# >>> push(3)
# а если он не пуст?

# >>> clear()
# >>> push(1)
# >>> push(2)
# >>> push(3)

# >>> pop()
# 3
# >>> pop()
# 2
# >>> pop()
# 1
# >>> is_empty()
# True

# Такой use case является сразу и минимальной документацией

# == Реализация A — на массиве/списке (list) ==
"""
Модуль, описывающий структуру данных стэк
>>> clear()
>>> is_empty()
True
>>> push(1)
>>> top()
1
>>> push(2)
>>> top()
2
>>> push(3)
>>> top()
3
>>> is_empty()
False
>>> top()
3
>>> pop()
3
>>> top()
2
>>> pop()
2
>>> top()
1
>>> pop()
1
>>> is_empty()
True
"""

_stack = []


def push(x):
    """
    Добавляет элемент x в конец стека
    
    >>> size = len(_stack)
    >>> push(5)
    >>> len(_stack) - size
    1
    >>> _stack[-1]
    5
    """
    _stack.append(x)

def pop():
    x = _stack.pop()
    return x

def clear():
    _stack.clear()

# практически получается обёртка над обычным пайтоновским списком (интерфейс к списку)
# также выходит что мы заужаем возможности списка
# это даёт нам гарантию функциональности:
# модуль может всё, что нужно, но не более
# реализация может меняться, а интерфейс останется прежним

def is_empty():
    return len(_stack) == 0

def top():
    return _stack[-1]

# тестирование
# доктест запускает документ-строку и проверяет, совпадают ли результаты
# молчаливое тестирование — не выдаёт результатов, если нет ошибок
if __name__ == "__main__":
    import doctest
    doctest.testmod()

# Имеет ли смысл создать этот модуль как класс?

# == Реализация B — на односвязном списке ==
