Дерево — связный граф, в котором:
1) между любыми V1 V2 есть только одна цепь
2) нет простых циклов
3) |V| = |E| + 1
любой вариант можно взять как определение, а другие два как следствие

Корневое дерево — дерево, в котором одна из вершнин считается корнем
Как только у дерева выделен корень, оно становится иерархичным

Высота дерева — количество рёбер до корня
Диаметр дерева <= 2*H дерева
Бинарное дерево — у каждой вершины не более двух рёбер
Остовное дерево — подграф связного графа, являющийся деревом, все вершины которого совпадают с вершинами родительского графа

--- 

Двоичное дерево — корневое дерево, где у любой вершины не более 2 дочерних

Упорядоченное корневое дерево — дерево, в котором важен порядок дочерних вершин

Двоичное дерево поиска — структура данных, хранящая элементы, содержащие ключ,
при этом ключи имеют критерий сравнимости
(можно линейно упорядочить ключи).

Левые дочерние элементы меньше родителя
Правые — больше родителя
Элементы добавляются по одному, последовательно сравниваются с имеющимися элементами
Время на поиск элемента пропорционально высоте дерева.

Как бы дерево ни было разбалансированно, его проекция всегда является упорядоченной (в отличие от хэш-таблицы)

Если дерево полное или сбалансированное, высота не высока:
H   N
0   1
1   3
2   7
3   15
k   2^(k+1) - 1
O(log N) — сравнимо с упорядоченным массивом (использовалось в бинарном поиске)
Минус упорядоченного массива: при помощи бинарного поиска найдём быстро, но добавление — O(N), т.е. массив хорош если не нужно добавлять
В двоичном дереве добавление занимает тоже O(log N)

Но:
Двоичное дерево может быть не сбалансированным (перекошенным в одну сторону, когда H ~ N)
 — тогда поиск и добавление аналогичны односвязному списку (O(N))

---

Балансировка двоичного дерева

Для того чтобы сбалансировать дерево, нужно перестроить его иерархию → уменьшить высоту

Дерево является сбалансированным, если 
для каждой вершины (включая корень) высота левого и правого поддеревьев отличается не более чем на 1

Алгоритмы балансировки:
— АВЛ-дерево
— Красно-чёрное дерево поиска

---

Малый левый поворот:
Если есть дисбаланс

  __k1__
 A    __k2__
     B    __k3__
нужно поднять k2 и опустить k1, левое поддерево k2 (B) переходит в подчинение к k1
      __k2__
  __k1__  __k3__
 A      B

Малый правый аналогичен

Иногда перекос одновременно повышает высоту сразу в двух уровнях иерархии, когда завалило не крайнее дерево (левое или правое), а центральное

Для решения применяется большой правый поворот:
Состоит в комбинации малого левого и малого правого поворотов

09 сильно перекошена налево, 05 на два уровня ниже 11:
          ___09___
      __03__      10__
  __01    __07__      11
00    __06      08
    05

малый левый поворот (поднимаем 07 в первый раз):

              ___09___
          __07__      10__
      __03__    08        11
  __01    __06     
00      05

перекос в 09 сохранился, теперь 07 тоже перекошена влево. 
Ещё раз поднимаем 07, совершая малый правый поворот:

           _____07_____
      ___03___      ___09___
  __01      __06  08        10__
00        05                    11

дерево более сбалансировано

---

ДДП — самостоятельная структура данных
На C++ реализуется на указателях, в Python — на ссылках
Звено дв. дерева поиска — это объект c данными (key, value) и 3 указателя/ссылки: (parent, left, right)
Указатели указывают на None либо на аналогичный объект. 