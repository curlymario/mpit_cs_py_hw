# ===== Индуктивные функции. Однопроходные алгоритмы =====

# === Что обрабатывают и что возвращают функции ===


# == На входе число (фиксированный кортеж чисел) → Результат число ==
# x → f(x)


# == На входе последовательность → Результат последовательность ==

# x1, x2, x3, ..., xn → f(x1), f(x2), f(x3), ..., f(xn)
# map()
# list comprehention    A → [f(x) for x in A]

# фильтрация
# x1, x2, x3, ..., xn → x1, x3, ..., xn-1
# A → [f(x) for x in A if cond]
# range()
# map()


# == На входе число → На выходе последовательность чисел (список, массив, множество) ==
# Генерирующие алгоритмы:
# — Все цифры числа
# — Разложить на множители
# — Численные последовательности (арифм/геом прогрессии, фиббоначи,)


# == На входе последовательность — Результат число ==
# Выжимки, выводы, статистические результаты
# Надо запоминать всю последовательность, пока работает алгоритм — неоднопроходные алгоритмы
# Однопроходные — не зависят от ограничений памяти (память константная)


# f([x1, ... xn]) = fn
# f([x1, ... xn, xn+1]) = fn+1

# Нужно ли мне знать все предыдущие xi для вычисления x или достаточно знать результат fn?
# Если достаточно, то fn+1 = F(fn, xn+1) — индуктивная функция

# функция f может быть вектором функции, вычислять не одно значение, а два значения 
# например: и сумму чисел последовательности и количество чисел в этой последовательности
# возможна ситуация, когда сама функция не является однопроходным алгоритмом (нельзя сформулировать индуктивную функцию), 
# но можно вычислить вектор функции, который будет индуктивной функцией


# === Способы редукции последовательности и виды индуктивных функций ===

#                                                       имя         []      [x1]      F(fn, x)
# Количество каких-то чисел (len)                       n           0       1        n += 1
# (всего, чётных, простых, положительных и т.д.)        
# Сумма (sum)                                           s           0       x1       s += x
# Произведение                                          p           1       x1       p *= x
# Логические проверки:
# Хотя бы один (any)                                    bs          false   c(x1)    bs = bs or c(x)
# Все (all)                                             bp          true    c(x1)    bp = bp and c(x)
# max                                                   m                   x1       m = max(m, x)    ← m = x if x > m
# частотный анализ                                      f                            f[x] += 1
