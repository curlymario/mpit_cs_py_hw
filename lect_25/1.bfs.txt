# Обход графов в ширину — breadth first search

— невзвешенные графы
— ориентированные и неориентированные
— храним граф в виде списка смежности (словарь с множествами соседей вершин)

Вершины добавляются не по цепочке, пока не упрёшься в тупик
А в ширину: обходим всех соседей пока не закончатся соседи,
каждую итерацию увеличиваем длину цепочек на одно ребро

Очередь обхода:
добавляем всех соседей обработанной вершины
обрабатываем вершины в очереди, добавляя всех соседей в конец очереди

Трудоёмкость: О(N+M)

Задачи:
— Выделение компонент связности в графе
— Поиск кратчайшего пути в невзвешенном графе
— Восстановление кратчайшего пути
— Нахождение кратчайшего цикла в ориентированном невзвешенном графе
— Находить остовное дерево графа
— Найти все рёбра, лежащие на кратчайшем пути между заданной парой вершин
— Найти все вершины, лежащие на кратчайшем пути между заданной парой вершин
— Найти кратчайший чётный путь в графе (т.е. путь чётной длины)
— Восстановление траектории шахматного коня
— Нахождение наиболее короткой цепочки друзей между двумя пользователями ВКонтакте

## Выделение компонент связности:
1. Полагаем кол-во компнонент = 0
2. Начинаем обход в ширину из произвольной вершины
3. Когда обход завершается, кол-во компонент += 1
4. Если остались непосещённые вершины, повторяем для них шаги 2–3,
сохраняя массив посещённых вершин
5. Если все вершины посещены, завершаем
О(N+M)

## Восстановление кратчайшего пути:
1. Совершаем обход в ширину с подсчётом расстояний
2. Для каждой вершины запоминаем родителя
3. Для восстановления пути обходим всех родителей от вершины до начала, потом разворачиваем полученный список

## Восстановление траектории шахматного коня
По каким клетка должен пройти конь, чтобы попасть из d4 в f2 наиболее быстро?
1. Сводим задачку к графу
2. Обход в ширину из одной точки в другую

## Нахождение кратчайшего цикла в ориентированном невзвешенном графе
1. Запускаем обход в ширину из каждой вершины
2. Как только пытаемся попасть в посещённую вершину — значит есть цикл
3. Запустив обход из каждой находим все и выбираем кратчайший

## Нахождение всех вершин на кратчайшем пути (a, b)
1. Запускаем обходы в ширину из a и из b с подсчётом расстояний
2. Расстояния до вершины x хранимкак d_a[x] и d_b[x]
3. Если d_a[x] + d_b[x] = d_a[b], то вершина лежит на кратчайшем пути.

## Нахождение всех рёбер на кратчайшем пути (a, b)
1. Запускаем обходы в ширину из a и из b с подсчётом расстояний
2. Расстояния до вершины x хранимкак d_a[x] и d_b[x]
3. Для ребра (u,v) проеряем d_a[u] + 1 + d_b[v] = d_a[b]
4. Если равенство выполнено, то ребро лежит на кратчайшем пути.

## Кратчайший путь четной длины
1. Строим вспомогательный граф:
— каждая вершина e превращается в две вершины: e0 и e1
— каждое ребро (u, v) превращается в 2 ребра: (u0, v1) и (u1, v0)
2. Найти кратчайший чётный путь из a в b == найти в новом графе кратчайший путь из a0 в b0


## Нахождение наиболее короткой цепочки друзей между двумя пользователями ВКонтакте
0. Получение данных: HTTP-запросы + VK API
1. Задаём id_start, id_end
2. Обходим