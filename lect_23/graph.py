# Хранение графа в памяти

# возьмём простейший граф:
# A -- B -- C -- D

# 1 список вершин + список рёбер
V = {"A", "B", "C", "D"}                    # N — порядок графа
E = {("A", "B"), ("B", "C") ("C", "D")}     # M — размер графа
# Быстро проверяем наличие вершины, ребра — О(1)
# Перебор всех соседей вершины — О(N)

# 2 матрица смежности
# подходит для простых графов
V = ["A", "B", "C", "D"]
# для быстрого доступа к индексам вершин
index = {V[i]: i for i in range(len(V))}    # dict comprehention
# матрица смежности:
#     A   B   C   D
# A   0   1   0   0
# B   1   0   1   0
# C   0   1   0   1
# D   0   0   1   0
# матрица квадратная
# все петли находятся на главной диагонали (здесь одни нули)
# если граф неориентированный, то матрица симметрична относительно главной диагонали (так)
# сумма всех единичек равна удовенному M
# сумма единиц в столбце или строке показывает степень вершины
# храним как список списков
A = [[0, 1, 0, 0],
     [1, 0, 1, 0],
     [0, 1, 0, 1],
     [0, 0, 1, 0]]
# факт проверки наличия ребра — О(1) + О(1)
# перебор всех соседей — О(M)
# главный плюс — простота реализации на любом сколь угодно убогом языке

# 3 Списки смежности
# для каждой вершины — множество соседей
# А: B
# B: A, C
# C: B, D
# D: C
G = {"A": {"B"},
     "B": {"A", "C"},
     "C": {"B", "D"},
     "D": {"C"}}
# факт проверки ребро или не ребро: ищем являются ли вершины соседями — О(1)
# перебор соседей:
for neighbour in G[v]:
    pass
# — O(число соседей)

# Чаще всего граф подают списком рёбер либо списком вершин

# Как мысленно разделять номера вершин и индексы
# 1. каждый раз считать +1 или -1
# 2. добавить фиктивную пустую вершину с индексом 0