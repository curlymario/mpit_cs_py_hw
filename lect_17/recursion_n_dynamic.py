"""
Факториал
Факториал не стоит решать через рекурсию (слишком быстро растёт сложность и объём памяти). но через факториал очень легко объяснять ркурсию
f(n) = 1, n = 0
f(n-1)*n, n>0
"""
def f(n:int) -> int:
    if n == 0:
        return 1
    return f(n-1)*n

"""
Динамическое программирование не требует функции
f = [1]*(n+1) # массив со значениями функции (резервируем место в памяти)
Постепенно расширяем наше понимание функции
f = [1] + [None]*n # более читабельно, но менее эффективно по памяти (создаётся лишний объек, который потом конкатинируется)
"""
f = [1] + [None]*n
for i in range (1, n+1):
    f[i] = f[i-1]*i
"""
в отличие от рекурсии, все результаты сохранены
кажется, мы выделяем целый массив и это неэффективно по памяти
но в рекурсии выделяется память под адрес возврата и локальная переменная n на каждом уровне глубины стека
рекурсия именно красива и ясно выглядит, но не имеет асимптотического преимущества
"""

"""
Фибоначчи
Fib(n) = n, n € {0, 1}
Fib(n) = Fib(n-1) + Fib(n-2), n > 1
"""

def fib(n:int) -> int:
    assert n >= 0
    if n <= 1:
        return n
    return fib(n-1) + fib(n-2)

""" 
раскрываем функцию динамически
append очень сильно жрёт вычисления при больших списках. каждый вызов требует дополнительной аллокации памяти, поэтому заранее выделяем память
[0, 1] + [0]*n — тоже не оптимально, сперва создаются два объекта, потом второй размножается, потом оба сливаются — очень неоптимально
"""
fib = [None]*(n+1)
fib[:2] = [0, 1]
for k in range(2, n+1):
    fib[k] = fib[k-1] + fib[k-2]

"""
Нельзя ли сохранить возможность рекуррентно оформлять, но сохранить преимущества динамического программирования?
Это называется рекурсия с кэшированием
"""
F = [None]*10000
def fib(n:int) -> int:
    assert n >= 0 and n <= 10000
    if F[n] is not None:
        return F[n]
    elif  n <= 1:
        F[n] = n
        return F[n]
    else:
        F[n] = fib(n-1) + fib(n-2)
        return F[n]

""" вариант записи покороче """
F = [None]*10000
def fib(n:int) -> int:
    assert n >= 0 and n <= 10000
    if F[n] is None:
        if  n <= 1:
            F[n] = n
        else:
            F[n] = fib(n-1) + fib(n-2)
    return F[n]